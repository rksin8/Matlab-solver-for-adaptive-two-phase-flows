function [Sol,eta] = bisection(Sol,eta,theta)
% BISECTION	refines the triangulation using newest vertex bisection
%
% USAGE
%    [Sol,eta] = bisection(Sol,eta,theta)
%
% INPUT 
%      Sol:  current mesh data with all variable data
%      eta:  error indicator for each triangle
%    theta:  parameter in (0,1). 
%            We mark minimal number of triangles M such that
%              \sum_{T \in M} \eta_T > \theta*\sum\eta_T
%
% OUTPUT
%      Sol:  new mesh data with interpolated variable data after refinement
%      eta:  new error indicator for each triangle
%
% REFERENCE
% 	Long Chen,
%   Short bisection implementation in MATLAB
%   Research Notes, 2006 
%

% L. Chen & C. Zhang 11-12-2006
%
% Modified by: Vaibhav Joshi, Rajeev K. Jaiman

%--------------------------------------------------------------------------
% Construct data structure
%--------------------------------------------------------------------------
edge = [Sol.elem(:,[1,2]); Sol.elem(:,[1,3]); Sol.elem(:,[2,3])];
edge = unique(sort(edge,2),'rows');

N = size(Sol.node,1);
NT = size(Sol.elem,1); 
NE = size(edge,1);

dualEdge = sparse(Sol.elem(:,[1,2,3]),Sol.elem(:,[2,3,1]),[1:NT,1:NT,1:NT]);
d2p = sparse(edge(:,[1,2]),edge(:,[2,1]),[1:NE,1:NE]);
% Detailed explanation can be founded at
%   Manual --> Data Structure -->  Auxlliary data structure 

%--------------------------------------------------------------------------
% Meomery management for node arrary
%--------------------------------------------------------------------------
recycle = find(Sol.type==0); 
last = length(recycle);
% Coarsening can create empty spaces in the node array. We collect those
% scattered spaces in recycle arrary and 'last' will point out the last
% empty node index. 
% mesh.type array is used to distinguish the type of nodes:
%   0: empty nodes (deleted by coarsening);
%   1: nodes in the initial triangulation or nodes from regular refinement;
%   2: new added nodes due to refinement;
%   5: temporay node (will be deleted when bisection finished).

%--------------------------------------------------------------------------
% Mark triangles according to the error indicator
%--------------------------------------------------------------------------
total = sum(eta); 
current = 0; 

[temp,ix] = sort(-eta); % sort in descent order
marker = zeros(NE,1); 

% initialize for possible new nodes
Sol.node = [Sol.node; zeros(NE,2)];
Sol.type = [Sol.type; uint8(5*ones(NE,1))];
Sol.u = [Sol.u; zeros(NE,2)];
Sol.uPrev = [Sol.uPrev; zeros(NE,2)];
Sol.uAlpha = [Sol.uAlpha; zeros(NE,2)];
Sol.uDot = [Sol.uDot; zeros(NE,2)];
Sol.uDotPrev = [Sol.uDotPrev; zeros(NE,2)];
Sol.uDotAlpha = [Sol.uDotAlpha; zeros(NE,2)];
Sol.p = [Sol.p; zeros(NE,1)];
Sol.pPrev = [Sol.pPrev; zeros(NE,1)];
Sol.phi = [Sol.phi; zeros(NE,1)];
Sol.phiPrev = [Sol.phiPrev; zeros(NE,1)];
Sol.phiAlpha = [Sol.phiAlpha; zeros(NE,1)];
Sol.phiDot = [Sol.phiDot; zeros(NE,1)];
Sol.phiDotPrev = [Sol.phiDotPrev; zeros(NE,1)];
Sol.phiDotAlpha = [Sol.phiDotAlpha; zeros(NE,1)];

for t = 1:NT
    
    if (current > theta*total), break; end % est on marked elem big enough
    
    index = 1; 
    ct = ix(t);
    
    while (index==1)
        
        base = d2p(Sol.elem(ct,2),Sol.elem(ct,3));
        if (marker(base)>0) % base is already marked
            index = 0;
        else
            current = current + eta(ct);
            if (last==0)
                newNode = N + 1; 
                N = N+1; 
            end
            if (last>0)
                newNode = recycle(last); 
                last = last-1; 
            end
            marker( d2p(Sol.elem(ct,2),Sol.elem(ct,3)) ) = newNode;

            % A new node is added to the mesh. Numerical solution at this
            % new added node is approximated by linear interpolation. Type
            % of this node is 2 (generated by newest vertex bisection)
            Sol.node(newNode,:) = ( Sol.node(Sol.elem(ct,2),:) + ...
                                     Sol.node(Sol.elem(ct,3),:) )/2;
            Sol.u(newNode,1) = ( Sol.u(Sol.elem(ct,2),1) + ...
                                   Sol.u(Sol.elem(ct,3),1) )/2;
            Sol.uPrev(newNode,1) = ( Sol.uPrev(Sol.elem(ct,2),1) + ...
                                   Sol.uPrev(Sol.elem(ct,3),1) )/2; 
            Sol.uAlpha(newNode,1) = ( Sol.uAlpha(Sol.elem(ct,2),1) + ...
                                   Sol.uAlpha(Sol.elem(ct,3),1) )/2;                    
            Sol.uDot(newNode,1) = ( Sol.uDot(Sol.elem(ct,2),1) + ...
                                   Sol.uDot(Sol.elem(ct,3),1) )/2;  
            Sol.uDotPrev(newNode,1) = ( Sol.uDotPrev(Sol.elem(ct,2),1) + ...
                                   Sol.uDotPrev(Sol.elem(ct,3),1) )/2;  
            Sol.uDotAlpha(newNode,1) = ( Sol.uDotAlpha(Sol.elem(ct,2),1) + ...
                                   Sol.uDotAlpha(Sol.elem(ct,3),1) )/2;  
            Sol.u(newNode,2) = ( Sol.u(Sol.elem(ct,2),2) + ...
                                   Sol.u(Sol.elem(ct,3),2) )/2;
            Sol.uPrev(newNode,2) = ( Sol.uPrev(Sol.elem(ct,2),2) + ...
                                   Sol.uPrev(Sol.elem(ct,3),2) )/2; 
            Sol.uAlpha(newNode,2) = ( Sol.uAlpha(Sol.elem(ct,2),2) + ...
                                   Sol.uAlpha(Sol.elem(ct,3),2) )/2;                    
            Sol.uDot(newNode,2) = ( Sol.uDot(Sol.elem(ct,2),2) + ...
                                   Sol.uDot(Sol.elem(ct,3),2) )/2;  
            Sol.uDotPrev(newNode,2) = ( Sol.uDotPrev(Sol.elem(ct,2),2) + ...
                                   Sol.uDotPrev(Sol.elem(ct,3),2) )/2;  
            Sol.uDotAlpha(newNode,2) = ( Sol.uDotAlpha(Sol.elem(ct,2),2) + ...
                                   Sol.uDotAlpha(Sol.elem(ct,3),2) )/2; 
            Sol.p(newNode) = ( Sol.p(Sol.elem(ct,2)) + ...
                                   Sol.p(Sol.elem(ct,3)) )/2;
            Sol.pPrev(newNode) = ( Sol.pPrev(Sol.elem(ct,2)) + ...
                                   Sol.pPrev(Sol.elem(ct,3)) )/2; 
            Sol.phi(newNode) = ( Sol.phi(Sol.elem(ct,2)) + ...
                                   Sol.phi(Sol.elem(ct,3)) )/2;
            Sol.phiPrev(newNode) = ( Sol.phiPrev(Sol.elem(ct,2)) + ...
                                   Sol.phiPrev(Sol.elem(ct,3)) )/2; 
            Sol.phiAlpha(newNode) = ( Sol.phiAlpha(Sol.elem(ct,2)) + ...
                                   Sol.phiAlpha(Sol.elem(ct,3)) )/2; 
            Sol.phiDot(newNode) = ( Sol.phiDot(Sol.elem(ct,2)) + ...
                                   Sol.phiDot(Sol.elem(ct,3)) )/2;
            Sol.phiDotPrev(newNode) = ( Sol.phiDotPrev(Sol.elem(ct,2)) + ...
                                   Sol.phiDotPrev(Sol.elem(ct,3)) )/2; 
            Sol.phiDotAlpha(newNode) = ( Sol.phiDotAlpha(Sol.elem(ct,2)) + ...
                                   Sol.phiDotAlpha(Sol.elem(ct,3)) )/2;                   
            Sol.type(newNode) = 2;
            
            % Find the element which shares the base edge of the current
            % element. If it is 0, it means the base of the current element
            % is on the boundary.
            ct = dualEdge( Sol.elem(ct,3), Sol.elem(ct,2) );
            if ( ct == 0 ), index = 0; end 
            % the while will ended if
            % 1.  ct==0 means we are on the boundary
            % 2.  base(ct) is already marked
            
        end
    end % end while for recursive marking
end % end of for loop on all elements
% Detailed explanation of the algorithm can be found at
%   Manual --> Algorithms --> Bisection

% delete possible empty entries
ix = (Sol.type == 5); 
Sol.node(ix,:) = []; 
Sol.type(ix) = [];
Sol.u(ix,:) = [];
Sol.uPrev(ix,:) = [];
Sol.uAlpha(ix,:) = [];
Sol.uDot(ix,:) = [];
Sol.uDotPrev(ix,:) = [];
Sol.uDotAlpha(ix,:) = [];
Sol.p(ix) = [];
Sol.pPrev(ix) = [];
Sol.phi(ix) = [];
Sol.phiPrev(ix) = [];
Sol.phiAlpha(ix) = [];
Sol.phiDot(ix) = [];
Sol.phiDotPrev(ix) = [];
Sol.phiDotAlpha(ix) = [];

%--------------------------------------------------------------------------
% Refine marked edges for each triangle
%--------------------------------------------------------------------------
numnew = 2*sum(marker~=0); % number of new elements need to be added
Sol.elem = [Sol.elem; zeros(numnew,3)];
eta = [eta; zeros(numnew,1)];

inew = NT + 1; % index for current new added right child
for t = 1:NT
    base = d2p(Sol.elem(t,2),Sol.elem(t,3));
    if (marker(base)>0)
        p = [Sol.elem(t,:), marker(base)];
        
        % Case 1: divide the current marked triangle
        Sol.elem(t,:)  = [p(4),p(1),p(2)]; % t is always a left child
        Sol.elem(inew,:) = [p(4),p(3),p(1)]; % new is a right child
        eta(t) = eta(t)/2; % update error indicators 
        eta(inew) = eta(t);
        inew = inew + 1;
        
        % Case 2: divide the right child, different, careful!!!
        right = d2p(p(3),p(1));
        if (marker(right)>0)
            Sol.elem(inew-1,:) = [marker(right),p(4),p(3)]; 
            Sol.elem(inew,:)   = [marker(right),p(1),p(4)];
            eta(inew-1) = eta(inew-1)/2;
            eta(inew) = eta(inew-1);
            inew = inew + 1;
        end

        % Case 3: divide the left child, similar to the case 1. 
        left = d2p(p(1),p(2));
        if (marker(left)>0)
            Sol.elem(t,:) = [marker(left),p(4),p(1)]; 
            Sol.elem(inew,:) = [marker(left),p(2),p(4)];  
            eta(t) = eta(t)/2;
            eta(inew) = eta(t);
            inew = inew + 1;
        end

    end % end of refinement of one element
end % end of for loop on all elements

% delete possible empty entries
Sol.elem = Sol.elem(1:inew-1,:);
eta = eta(1:inew-1,:);

%--------------------------------------------------------------------------
% Update boundary edges
%--------------------------------------------------------------------------
Sol.Dirichlet = updatebd(Sol.Dirichlet,marker,d2p);
Sol.Neumann   = updatebd(Sol.Neumann,marker,d2p);

%--------------------------------------------------------------------------
% End of function BISECTION
%--------------------------------------------------------------------------

%--------------------------------------------------------------------------
% Sub functions called by BISECTION
%--------------------------------------------------------------------------

function bdEdge = updatebd(bdEdge,marker,d2p)
% UPDATEDBD refine the boundary edges
%
% USAGE
%    bdEdge = updatebd(bdEdge,marker,d2p)
%
% INPUT
%   bdEdge:  set of boundary edges
%   marker:  new node index for marked edge
%      d2p:  index mapping from dual edge to primary edge
% 
% OUTPUT
%   bdEdge:  set of refined boundary edges
%

NB = size(bdEdge,1);
for k = 1:NB
     i = bdEdge(k,1); 
     j = bdEdge(k,2);
     if (marker(d2p(i,j)) >0)
         bdEdge(k,:) = [i,marker(d2p(i,j))];
         bdEdge(size(bdEdge,1)+1,:) = [marker(d2p(i,j)),j];
     end
end
%--------------------------------------------------------------------------
% End of function UPDATEDBD
%--------------------------------------------------------------------------
